Introduction to Angular 8
_________________________
Topics:
__________
	- Introduction , Different Building blocks
	- component: What are components, how to create components?
	- Data Binding in angular: one way , two way
	- Angular Directive: ngFor, ngIf
	- Angular pipes
	- angular services
	- http services
	- applying routing
	- applying guards routes in angular
	- angular forms and validations
	- angular testing jasmine and karma
	

	
_____________________________________________
- Introduction , Different Building blocks
_____________________________________________


Angular vs angularjs
____________________

	=> Angular is is not a simple upgrade from angular 1 
	=> Angular  is completely rewritten, 
		so it has lot of improvements when compared with Angular 1. 

improvements
____________

	=> Performance : 
	____________
	- faster initial loads, change detection, and improved rendering time. 
	- improved modularity, Dependency injection and testability. 
	- Angular 2 is 5 times faster compared to AngularJS 1. 


	Mobile Support : 
	____________
	- Angular 1 was not built for mobile devices. 
	- Angular 2 on the other hand is designed from the ground up with mobile support. 


	Component Based Development :
	________________________
	-  "everything is a component". Components are the building blocks of an Angular application.
	 - it facilitates greater code reuse. 
	- the use of components make Angular2 more testable. 


	Build on typescript
	____________________
	- Early error checking
	- TypeScript has great support of ECMAScript 6 standard. S



Building block of angular:
________________________

=> Component
=> module
=> services
=> pipes


component?
____________

	=> typescrpt class with a template and a decorator

	component= Template + class + decorators

	Template 
		-Defines the user interface. Contains the HTML, directives and bindings.

	Class 
		- Contains the contain the logic for the view. 

	Decorator 
		- A class becomes an Angular component, 
		when it is decorated with the Component decorator.




getting started with angular 8:
_________________________________

upgrading nodejs (min node 12)
node --version
https://www.youtube.com/watch?v=IjJxHfWiz9Y



install angular 8.x
_____________________

npm install -g @angular/cli@8.3.19

checking version:
---------------
ng --version

creating project:
---------------
ng new helloapp

Running:
------
ng serve --open


creating new module:
ng g c test


 
Simplest ex:
____________

@Component({
    
    selector: 'my-app',
   
    template: `<h1>Hello {{name}}</h1>`,
})

export class AppComponent {
    name: string = 'Angular';
}


template vs templateUrl
________________________

import { Component } from '@angular/core';

@Component({
    selector: 'my-app',
    templateUrl: 'app/app.component.html'
})
export class AppComponent {
    name: string = "Angular";
}





_______________________________________________
- Data Binding in angular: one way , two way
________________________________________________


Interpolation in Angular
________________________

	-Interpolation is all about data binding in angular

Data Binding		Description				How
-----------------------------------------------------------------------------
One way ==========>	From Component to View Template    Interpolation and Property binding
One way ==========>	From View Template to Component	   event binding
Two way ==========>	From Component <===> Template 	   <input [(ngModel)]='name'>




1.One way data biding using Angular Interpolation {{}}
____________________________________________________________
	Interpolation {{}} used for data binding from C==> V
____________________________________________________________

@Component({
  selector: 'app-root',
  template: `<h4>{{20+20}}<h4>
    {{title}}<br/>
    {{name}}<br/>
    {{fullname()}}
  `,
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title:string = 'hello to angular framework';
  fname:string='rajeev';
  lname:string='gupta';

  fullname():string{
    return `${this.fname} and ${this.lname}`
  };

}



1.One way data biding using Property binding [ ]
________________________________________________
Interpolation {{}} used for data binding from C==> V
________________________________________________

	=> Interpolation is an alternative of Property binding only work for
	 string (not for boolean etc:, hence property binding is better

Ex:

@Component({
  selector: 'app-test',
  template: `
  
  Name <input type="text" name="name" value ={{name}}/> <br/>
  Name <input type="text" name="name" [value]="name"/> <br/>


  <div hidden={{isHidden}}>this is a div</div>
  <div [hidden]="isHidden">this is a div2</div>

  `,
  styleUrls: ['./test.component.css']
})
export class TestComponent implements OnInit {

  name:string='raj';
  isHidden:boolean=false;
  constructor() { }

  ngOnInit() {
  }

}



2. Event binding in Angular
___________________________
One way binding from V ==> C
___________________________

Hello world:

<button (click)=myenvent()>call event</button>
    {{count}}


export class AppComponent {

  count =0;
  data = '';
  myenvent(){
    ++this.count;
  }
}

Using $(event)
_____________

template: `
    <input type="text" (keyup)=callmethod($event)/>
    <p>{{data}}
  `,


export class AppComponent {

  //
  callmethod(event){
    this.data +=event.target.value+";";
	console.log(event);
  }
}




3. 2 Way data binding: ngModel
_________________________________
 Two way binding from V <==> C
_________________________________

	=> build in directive, [()]

Example:

 Email <input type='text'  [(ngModel)]='email'/><br/>
      <button (click)=getEmail()>click me</button>
    
    {{email}}
  



(click)=getEmail()

export class AppComponent {
  title = 'exp1';
  email = 'r@r.gupta';

  getEmail(){
    console.log(this.email);
  }
}


	Note:
	=> Error:Can't bind to 'ngModel' since it isn't a known property of 'input'. (

	=> Before using ngModel directive in a two way data binding, 
		we must import the FormModule and add it to the NgModules import list

	=> import forms modules into app.module.ts

	import { FormsModule } from '@angular/forms';

	and put to imported list:

	imports: [
   	 BrowserModule,
    	FormsModule
  	]




Simple cal using angular 2 way binding
________________________________________

    First no: <input [(ngModel)] ='num1' type="number" name="num1"/><br/>
    Second no: <input [(ngModel)] ='num2' type="number" name="num2"/><br/>
    <button  (click) = 'addition()'>Calculate</button>
   
	{{num1}} + {{num2}}={{result}}


import { Component } from '@angular/core';

@Component({
  selector: 'app-cal',
  templateUrl: './cal.component.html',
  styleUrls: []
})
export class CalComponent {

  public num1:number=0;
  public num2:number=0;
  public result:number=0;

  addition() {
    this.result= this.num1+ this.num2;
  }

}

=> dont forget to add FormsModule to app.module.ts


import { FormsModule } from '@angular/forms';

	and put to imported list:

	imports: [
   	 BrowserModule,
    	FormsModule
  	]



____________________________________________
Angular Directive: ngFor, ngIf etc
____________________________________________

Angular Directive:
______________________

	=> Directive add custom behaviour to our html pages
	=> Basically they are attribute to html pages
	=> Example ngFor, ngIf,ngSwitch, ngClass etc
	=> Inbuild and Custom directive


ngFor
_________

	Syntax:	*ngFor='let employee of employees'

Ex:

step 1: create an component: employeelist
______________________________________

import { Component } from '@angular/core';

@Component({
    selector: 'list-employee',
    templateUrl: 'app/employee/employeeList.component.html',
    styleUrls: ['app/employee/employeeList.component.css']
})
export class EmployeeListComponent {
    employees: any[] = [
        {
            code: 'emp101', name: 'Raj', gender: 'Male',
            annualSalary: 5500, dateOfBirth: '25/6/1988'
        },
        {
            code: 'emp102', name: 'Keshav', gender: 'Male',
            annualSalary: 5700.95, dateOfBirth: '9/6/1982'
        },
        {
            code: 'emp103', name: 'Gunika', gender: 'Female',
            annualSalary: 5900, dateOfBirth: '12/8/1979'
        },
        {
            code: 'emp104', name: 'Ekta', gender: 'Female',
            annualSalary: 6500.826, dateOfBirth: '14/10/1980'
        },
    ];
}


html page:
__________

<table>
    <thead>
        <tr>
            <th>Code</th>
            <th>Name</th>
            <th>Gender</th>
            <th>Annual Salary</th>
            <th>Date of Birth</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </tbody>
</table>


code
name
gender
annualSalary
dateOfBirth

<table>
    <thead>
        <tr>
            <th>Code</th>
            <th>Name</th>
            <th>Gender</th>
            <th>Annual Salary</th>
            <th>Date of Birth</th>
        </tr>
    </thead>
    <tbody>
        <tr *ngFor='let employee of employees'>
            <td>{{employee.code}}</td>
            <td>{{employee.name}}</td>
            <td>{{employee.gender}}</td>
            <td>{{employee.annualSalary}}</td>
            <td>{{employee.dateOfBirth}}</td>
        </tr>
        <tr *ngIf="!employees || employees.length==0">
            <td colspan="5">
                No employees to display
            </td>
        </tr>
    </tbody>
</table>




css:
_______
table {
    color: #369;
    font-family: Arial, Helvetica, sans-serif;
    font-size: large;
    border-collapse: collapse;
}

td {
    border: 1px solid #369;
    padding:5px;
}

th{
    border: 1px solid #369;
    padding:5px;
}




Example 2:  angular directive:


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-test',
  template: `
    <h2 *ngIf="displayName; else nameElseBlock">
      Rajeev gupta
    </h2>
    <ng-template #nameElseBlock>
      <h2>
        Name is hidden
      </h2>
    </ng-template>

    <div *ngIf="displayName; then thenBlock; else elseBlock"></div>

    <ng-template #thenBlock>
      <h2>Rajeev Gupta</h2>
    </ng-template>

    <ng-template #elseBlock>
      <h2>Hidden</h2>    
    </ng-template>



    <div [ngSwitch]="color">
      <div *ngSwitchCase="'red'">You picked red color</div>
      <div *ngSwitchCase="'blue'">You picked blue color</div>
      <div *ngSwitchCase="'green'">You picked green color</div>
      <div *ngSwitchDefault>Pick again</div>
    </div>


    <div *ngFor="let color of colors; index as i">
      <h2>{{i}} {{color}}</h2>
    </div>

  `,
  styles: []
})
export class TestComponent implements OnInit {

  public displayName = false;
  public color = "red";
  public colors = ["red","blue","green","yellow"]

  constructor() { }

  ngOnInit() {
  }

}



____________________________________________
	Angular pipes
____________________________________________


Angular pipes |
_________________

	=> A pipe is used to format the value of an expression displayed in the view

	=> Angular comes with multiple predefined pipes such as date curreny, lowercase, upper case and others
	=> Built in pipes include lowercase, uppercase, decimal, date, percent, currency etc

	=> Syntex :{{expression | pipeName:inputParam1}}

	=> If pipe takes multipe inputs then they can be placced one
	after another separated by a colon :
	=> Ex: {{fullname | slice:0:20}}
	=> pipes can be chained, ie output from one pipe can serve as the input to another pipe
	=> Common pipes:

	=> date: date filter is used to formate the date in a specified manner
	=> uppercase and lowercase: chagne the case of input string
	=> decimal and percent: based on current brower locale
	=> currency: used to format numeric values as a currency based on the current brower locale

	{{14.22 | currency:"USD"}} {{14.2 |currency:"USD":true}}

	=> json: handy pipe that convert any input into 
a json string using JSON.stringify

Ex: date pipe:
_________________

@Component({
  selector: 'app-root',
  template:`
    <p> simple date is :{{mydate | date}} </p> <br/>
    <p> medium date is :{{mydate | date: 'medium'}} </p> <br/>
    <p> short date is :{{mydate | date: 'short'}} </p> <br/>
    <p> full date is :{{mydate | date: 'fullDate'}} </p> <br/>
    <p> custom date is :{{mydate | date: 'yyyy-mm-dd HH:mm a z ':' +0900}} </p> <br/>
  `,
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app1';
  mydate=Date.now();

}

currrency pipe:
______________

	<p> currrency : {{123456 | currency: 'EUR' }}</p>

Decimal pipe:
_____________
	=> This pipe is uesd for transformation of decimal numbers

	=> The first arguement is a formate string of the form
	"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"


	Ex: {{2.24159265 | number: '3.1-2'}} Output: 002.24
	Ex: {{3.15159265 | number: '1.4-4'}} Output: 3.1416

Ex:
	<p> currrency : {{123456 | currency: 'EUR' }}</p>
  <p> currrency : {{123456 | currency: 'EUR' : true }}</p>
  <p> currrency : {{123456 | currency: 'USD' : true }}</p>
  <p> no : {{2.24159265 | number: '3.1-2'}} </p>
  <p> no : {{3.15159265 | number: '1.4-4'}}</p>


JsonPipe
____________
	=> this transforms a javascript object into a JSON string
	=> object : Object ={fname:'rajeev',lname:'gupta'};

	 <p> json objet: {{object | json }} </p>

Ex:
<p>json object {{ object | json }} </p>
 object: object= { fname:'rajeev', lname:'gupta' };


Ex: 
---
	<td>{{employee.code | uppercase}}</td>
	We can also chain pipes<td>{{employee.dateOfBirth | date:'fullDate' | uppercase }}</td>
	
	Pass parameters to pipe using colon " : "
	<td>{{employee.annualSalary | currency:'USD':true:'1.3-3'}}</td>
	<td>{{employee.dateOfBirth | date:'fullDate'}}</td>
	<td>{{employee.dateOfBirth | date:'dd/MM/y'}}</td>



creating a Custom Pipe in Angular
_______________________________
 	=> Depending on the gender of the employee, 
	we want to display Mr. or Miss. prefixed to the employee name 


angular pipes:
_____________
	
Custom pipe?
_____________
	=> the pipe is a class that contain "pipe" metadata

	=> the pipe class contains method "transform",
	 which is implememented from "PipeTransform" interface. 
	This method accepts the value and optionally accept the arguments 
	and convert it to the required formate

	=> we can add the required argument to the "transform" method

	=> the @pipe decorator is used to declare pipe and it is defined in core 
	angular library, we we need to import this library. 
	This decorator allow us to define the name of the pipe, which is used in html markup

	=> The 'transform' method can return any type of value. 

	=> If our pipe's return type is decided on run time, we can use 'any' 
		otherwise we can defind specific type such as number or string



command to generate pipe : ng g pipe employeeTitle

Step 1: create pipe employeeTitle
_______________________________
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'empTitle'
})
export class EmpTitlePipe implements PipeTransform {

  transform(value: string, gender: string): any {
    if (gender.toLowerCase() === 'male' ) {
      return 'Mr.' + value;
    } else {
      return 'Miss.' + value;
    }
  }
}


Step 2: register pipe in AppModule (done automatically)
____________________________________

import { EmpTitlePipe } from './emp-title.pipe';

@NgModule({
  declarations: [
	...
    EmpTitlePipe
  ],
  imports: [
    BrowserModule,
    AppRoutingModule, FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})

export class AppModule { }


Step 3: start using pipe
_____________________
<tr *ngFor='let employee of employees;'>
    <td>{{employee.code}}</td>
    <td>{{employee.name | employeeTitle:employee.gender}}</td>
    <td>{{employee.gender}}</td>
    <td>{{employee.annualSalary}}</td>
    <td>{{employee.dateOfBirth}}</td>
</tr>






_____________________________
	Angular services:
_____________________________

hard coded
____________

ng g c emp -it -is
ng g c empdetails -it -is

Example:


<ul *ngFor = "let emp of employees">
    <li>{{emp.name}}</li>
</ul>

public employees=
[
    {"id": 1, "name": "Rajev", "age": 40},
    {"id": 2, "name": "Ekta", "age": 38},
    {"id": 3, "name": "Keshav", "age": 26},
    {"id": 4, "name": "Gunika", "age": 28},
    {"id": 5, "name": "Vikas", "age": 25}    
]




Problem? SRP, DRY
__________________
step 1: generate emp service
	ng g s emp

step 2: create a function to return list of employees

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class EmpService {

  constructor() { }

  getEmployees(){
   return [
      {"id": 1, "name": "Rajev", "age": 40},
      {"id": 2, "name": "Ekta", "age": 38},
      {"id": 3, "name": "Keshav", "age": 26},
      {"id": 4, "name": "Gunika", "age": 28},
      {"id": 5, "name": "Vikas", "age": 25}    
  ];
  }
}




step 3: Now create an empty array in employee component
___________________________

public employees=[];


step 4: Register service in in app.module.js


import { EmpService } from './emp.service';
  providers: [EmpService],



step 5: Declare and use DI in Employee component


import { EmpService } from '../emp.service';




export class EmpComponent implements OnInit {

  public employees=[];
  
  constructor(private _es: EmpService) {
   }

  ngOnInit() {
    this.employees=this._es.getEmployees();
  }

}



Angular services:
______________
	http
______________

sudo npm install rxjs@6 rxjs-compat@6 -–save


step 1: import httpclient module to app.module.ts  and regester it
_________________________________________________________


import { HttpClientModule} from '@angular/common/http';

imports: [
    BrowserModule , HttpClientModule
  ],


step 2: Inject the service in employee.service.ts
_________________________________________________

import {HttpClient} from '@angular/common/http';

constructor(private http: HttpClient) { }



step 3: now in getEmployees() method will fetch data from a file folder... assets/data/emps.json
_________________________________________________________

put data in file emps.json

[
      {"id": 1, "name": "Rajev", "age": 40},
      {"id": 2, "name": "Ekta", "age": 38},
      {"id": 3, "name": "Keshav", "age": 26},
      {"id": 4, "name": "Gunika", "age": 28},
      {"id": 5, "name": "Vikas", "age": 25}    
]



private _url = 'assets/data/emps.json';

  constructor(private http: HttpClient) { }

  getEmployees(){
   return this.http.get(this._url);
  }

//Error: http.get() return Obserable and we need to cast to Employee




Step 4: Now create employee interface 
________________________________

ng generate interface Employee

export interface Employee {
    id: number;
    name: string;
    age: number;
}


Now change return type to Observable<Employee[]>
_________________________________________________

import { Observable } from 'rxjs';
import { Employee } from './employee';

@Injectable({
  providedIn: 'root'
})
export class EmpService {

  private _url = 'assets/data/emps.json';

  constructor(private http: HttpClient) { }

  public getEmployees(): Observable<Employee[]>{
   return this.http.get<Employee[]>(this._url);
  }
}


step 5: Now we need to subscribe obserable from emp component and assign employees to 
a local variable


export class EmpComponent implements OnInit {

  public employees=[];
  
  constructor(private _es: EmpService) {
   }

  ngOnInit() {

    this._es.getEmployees().subscribe
    (data => this.employees = data);
  }

}





step 6: Error handling
________________________________


step 1: import into emp.service.ts

import {HttpClient, HttpErrorResponse} from '@angular/common/http';
import { throwError, Observable } from 'rxjs';
import { catchError } from 'rxjs/operators';



 getEmployees(): Observable<Employee[]> {
    return this.http.get<Employee[]>(this._url).pipe(catchError(this.errorHandler));
   }

   errorHandler(error: HttpErrorResponse) {
    return throwError(error.message || 'Server Error!');
  }



step 2: now we need to update emp component to handle errors


export class EmpComponent implements OnInit {

  public employees=[];
  public errorMessage;

  constructor(private _es: EmpService) {
   }

  ngOnInit() {
    this._es.getEmployees().subscribe
    (data => this.employees = data ,
      error => this.errorMessage = error);
  } 

}

_______________________________
 - applying routing
_______________________________


Introduction to routing?
__________________________

	=> web applications can have different sections that corrosponds to 
	different URLs and supporting those section programmatically is called routing

	=> In simple words, as per url open different angular components is called routing


app-component.html
----------------------

<router-outlet></router-outlet>

Example:

step 1: create an angular project with routing option

step 2: create two components 
 ng g c emplist -it -is
 ng g c deptlist -it -is




step 3: configure the route in routing module app-routing-module.ts

create an route consist of two components 



import { DeptlistComponent } from './deptlist/deptlist.component';
import { EmplistComponent } from './emplist/emplist.component';

const routes: Routes = [
  { path : 'departments', component: DeptlistComponent},
  { path : 'employees', component: EmplistComponent}
];



=> now create two links in app.component.html



<nav>
  <a routerLink="/departments" >departments</a><br/>
  <a routerLink="/employees">employees</a><br/>
</nav>

href vs routerLink


wilidcard routing and redirect routing
_______________________________

 => what if user request for an route that dont exist, we get error on console
 => we need to configure wildcard route

step 1: 
ng g c page-not-found -it -is

step 2:
 define wildcard routing

import { PageNotFoundComponent } from './page-not-found/page-not-found.component';



const routes: Routes = [
  
  { path : '**', component: PageNotFoundComponent}
];


Note: wildcard must be last route configured...



Now new problem:
______________

	=> we are getting "page not found"
	when we go to http://localhost:4200/ 

	=> we need a deafult route


const routes: Routes = [
  { path : '', component: DeptlistComponent},
  { path : 'departments', component: DeptlistComponent},
  { path : 'employees', component: EmplistComponent},
  { path : '**', component: PageNotFoundComponent}
];


const routes: Routes = [
  { path : '', redirectTo: '/departments', pathMatch: 'full'},
  { path : 'departments', component: DeptlistComponent},
  { path : 'employees', component: EmplistComponent},
  { path : '**', component: PageNotFoundComponent}
];



Routing parameters:
______________________

	we want to nevigate to department detail component if 
	we click an particular department

Dept 			Deptdetail
----------------------------------------

angular   id		you selected dept with id =1
node	-------> 
mongo
java


step 1: update dept component


 <ul class="item">
  <li *ngFor="let department of departments">
    <span class="badge">{{department.id}}</span> {{department.name}}
  </li>
</ul>



  public departments = [
    {"id": 1, "name": "Angular"},
    {"id": 2, "name": "Node"},
    {"id": 3, "name": "MongoDB"},
    {"id": 4, "name": "Ruby"},
    {"id": 5, "name": "Bootstrap"}
  ]



step 3: generate new component 
ng g c dept-detail -it -is

step 4: add route for this component in app-routing module

{ path : 'departments/:id', component: DeptDetailComponent}


step 5: update dept component to 


import { Router } from '@angular/router';

@Component({
  selector: 'app-deptlist',
  template: `
  <ul class="item">
  <li (click)="onSelect(department)"  *ngFor="let department of departments">
    <span class="badge">{{department.id}}</span> {{department.name}}
  </li>
</ul>
  `,
  styles: []
})
export class DeptlistComponent implements OnInit {

  public departments = [
    {"id": 1, "name": "Angular"},
    {"id": 2, "name": "Node"},
    {"id": 3, "name": "MongoDB"},
    {"id": 4, "name": "Ruby"},
    {"id": 5, "name": "Bootstrap"}
  ]

	//i want to nevigate programmatically from one rounte to another (imp)
  constructor(private rounter: Router) { }

  ngOnInit() {

  }

  onSelect(department){
    // from neviate from code to rooute we need router service
    this.rounter.navigate(['/departments', department.id]);
  }
}



Step 6: we want to access parameter (dept id) in department detail module and use it threre

we have to use "ACTIVATED ROUTE SERVICE"

go to dept detail service and update:



import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router, ParamMap } from '@angular/router';
@Component({
  selector: 'app-dept-detail',
  template: `<h3>you selected dept with id {{deptId}}</h3>`,
  styleUrls: []
})
export class DeptDetailComponent implements OnInit {

  public deptId; 

  constructor(private route: ActivatedRoute) { }

  ngOnInit() {
    // tslint:disable-next-line: radix
    let id= parseInt(this.route.snapshot.paramMap.get('id'));
    this.deptId = id;
  }
}





Lab assignment:
________________

category, product , product-details, product-not-found










______________________________________
- applying guards routes in angular
______________________________________

guards routes in angular:
__________________________

	=> The Angular supports several guards like CanActivate, 
	CanDeactivate, Resolve, CanLoad, and CanActivateChild. 

	=> These guards help us to secure the route or to perform some actions before navigating 
	into a route or leaving the route


Why guards routes?
_____________________

	=> Allowing the user to navigate all parts of the application is not a good idea.
	 We need to restrict the user until the user performs specific actions like login.
	 Angular provides the Route Guards for this purpose.

	One of the common scenario, where we use Route guards is authentication. 
	We want our App to stop the unauthorized user from accessing the protected route. 
	We achieve this by using the CanActivate guard, which angular invokes when the 
	user tries to navigate into the protected route.

	 Then we hook into the CanActivate guard and use the authentication service to check whether the user is 			authorized to use the route and if not we can redirect the user to the login page.


Uses of  Angular Route Guards
________________________________

	To Confirm the navigational operation
	Asking whether to save before moving away from a view
	Allow access to certain parts of the application to specific users
	Validating the route parameters before navigating to the route
	Fetching some data before you display the component

Types of Route Guards
______________________

The Angular Router supports Five different guards, which you can use to protect the route

CanActivate:
	This guard decides if a route can be activated (or component gets used). 
	This guard is useful in the circumstance where the user is not authorized 
	to navigate to the target component Or the user might not be logged into the system


CanDeactivate:
	The CanDeactivate route allows us to ask user confirmation before leaving the component.  
	You might ask the user if it’s OK to discard pending changes rather than save them.

Resolve:

	This guard delays the activation of the route until some tasks are complete.
	 You can use the guard to pre-fetch the data from the backend API, before activating the route


CanLoad:
	The CanLoad Guard prevents the loading of the Lazy Loaded Module. 
	We generally use this guard when we do not want to unauthorized user 
	to be able to even see the source code of the module.



CanActivateChild:
	This guard determines whether a child route can be activated. 
	This guard is very similar to CanActivateGuard. We apply this guard to the parent route. 
	The Angular invokes this guard whenever the user tries to navigate to any of its child route.
	 This allows us to check some condition and decide whether to proceed with the navigation or cancel it.


app.compoent.html:
________________

<nav class="navbar navbar-expand-sm bg-primary navbar-dark">
  <ul class = "navbar-nav">
    <li class = "nav-item">
      <a routerLink="home" routerLinkActive="active" class="nav-link" >home</a>
  </li>
      <li class = "nav-item">
          <a routerLink="admin" routerLinkActive="active" class="nav-link" >admin</a>
      </li>
      
  </ul>
</nav>
<div class="text-center">
  <router-outlet></router-outlet>
</div>





ng g c admin -is -it

ng g c home -is -it


ng g g activate



@Injectable({
  providedIn: 'root'
})
export class ActivateGuard implements CanActivate {
  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    return true;
  }
  
}



ng g s user


mention services in provider array in app.module.ts


  providers: [ActivateGuard, UserService],




Define routes:
--------------

const routes: Routes = [
  {path:'', component: HomeComponent},
  {path:'home', component: HomeComponent},
  {path:'admin', component: AdminComponent, canActivate:[ActivateGuard]}
];







Write isAdminRight() to return true/false:
---------------------------------------


export class UserService {

  constructor() { }

  isAdminRight():boolean{
    return true;
  }
}



use user service in ActivateGuard:
---------------------------------

@Injectable({
  providedIn: 'root'
})
export class ActivateGuard implements CanActivate {
  constructor(private _us:UserService, private router: Router){

  }
  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    
      if(this._us.isAdminRight()){
        return true;
      }else{
        alert('you dont have admin permission');
        this.router.navigate(['home']);
      }
    
      return true;
  }
  
}





@NgModule({
  declarations: [
    AppComponent,
    AdminComponent,
    HomeComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule
  ],
  providers: [ActivateGuard, UserService],
  bootstrap: [AppComponent]
})
export class AppModule { }










intermodule communication in angular:
___________________________________
	=> by default we have a angular module ie called app.module
	=> we can have more then one module in our application
	=> lets say we have mod1 with an component called comp1

	=> we want to use comp1 in app.module

	steps:
	1. create new module
	ng g m mod1
	2. create an component inside that module
	ng g c mod1/comp1
	
	3. ask mod1 to exports comp1

	exports:[
    		Comp1Component
	  ]

	4. import mod1 to app.module
	

	  imports: [
	    BrowserModule, Mod1Module
	  ],


	

Angular forms:
_________________

1)Template driven form
2)Model driven ( reactive form)


template driven form:
_____________________
	template-driven forms place the emphasis on developing a form within an HTML 
	template and handling most of the logic for the form-inputs, data validation, saving, 
	and updating-in form directives placed within that template.

	Very less code required because most of the forms related work 
	have been done by the angular framework itself.

	heavy use of the ngModel form directive 

	=> dont forget to add FormsModule to app.module.ts

	import { FormsModule } from '@angular/forms';




Example :

<form #f="ngForm"  (ngSubmit)="onSubmit(f.value)">
<input type='text' name='fname' ngModel  required />
<input type='text' name='lname' ngModel required />
<input type='submit' [disabled]="f.invalid" value='click here' />
<span> {{ fname }}</span>
<span> {{ lname }}</span>
</form>


  fname="";
  lname="";
  onSubmit(form: any): void{
    console.log(form);
    this.fname = form.fname;
    this.lname = form.lname;
}





form validation :

<form #frm ="ngForm" (ngSubmit)="addUser(frm.value)">
    <div class="">
        <label for ="name">
            Name: 
        </label>
        <input type="text" name="name" ngModel>
    </div>
    
    <div class="">
        <label for ="contact">
            Contact: 
        </label>
        <input type="text" name="contact" ngModel>
    </div>
    
    <div class="">
        <label for ="email">
            email: 
        </label>
        <input type="text" name="email" ngModel>
    </div>
    <button type="submit" name="button">add user</button>
</form>
{{ frm.value | json}}




 addUser(form: any): void {
    console.log(form);
  }


form with validation:
-------------------

<form #frm ="ngForm" (ngSubmit)="addUser(frm)">
    <div class="">
        <label for ="name">
            Name: 
        </label>
        <input type="text" name="name" ngModel required pattern="[a-zA-Z]{5,}+">
    </div>
    
    <div class="">
        <label for ="contact">
            Contact: 
        </label>
        <input type="text" name="contact" ngModel required pattern="[0-9]*">
    </div>
    
    <div class="">
        <label for ="email">
            email: 
        </label>
        <input type="text" name="email" ngModel required pattern="^(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\-+)|([A-Za-z0-9]+\.+)|([A-Za-z0-9]+\++))*[A-Za-z0-9]+@((\w+\-+)|(\w+\.))*\w{1,63}\.[a-zA-Z]{2,6}$">
    </div>
    <button type="submit" name="button" [disabled] ="frm.invalid" >add user</button>
</form>
{{ frm.value | json}}


Display error message:
---------------------
  <div class="">
        <label for ="name">
            Name: 
        </label>
        <input type="text" name="name" ngModel required #nameUser="ngModel"  pattern="[a-zA-Z][a-zA-Z]+">
    </div>
    <div *ngIf="nameUser.errors?.required">
        name is required
    </div>



Problem : error should be only displayed if field is left blank


<div *ngIf="nameUser?.touched">
        <div *ngIf="nameUser.errors?.required">
            name is required
        </div>
    </div>


pattern checking?
------------------

<div *ngIf="nameUser?.touched">
        <div *ngIf="nameUser.errors?.required">
            name is required
        </div>
        <div *ngIf="nameUser.errors?.pattern">
            please enter correct pattern
        </div>
    </div>



2)Model driven ( reactive form)
-------------------------------

	1.It is also called reactive forms.

	2.In this approach, we have to add an additional layer of complexity and 
	functionality by having you to declare the model of the form in your component class.

	3.We represent the form as a model composed of instances of FormGroups and FormControls.

	4.HTML for our form isn’t automatically created for us in model-driven approach.

	5.need to write the HTML that represents our form and then explicitly link the HTML
	 form elements to code on our component.

	6.We represent the form as a model composed of instances of FormGroups and FormControls.


Example:
------------
<form [formGroup]="myform">

    <fieldset formGroupName="name">
    <div class="form-group">
       <label>First Name</label>
       <input type="text" class="form-control"  formControlName="firstName" required>
    </div>

    <div class="form-group">
    	<label>Last Name</label>
    	<input type="text" class="form-control" formControlName="lastName"  required>
    </div>
    </fieldset>

    <div class="form-group">
    	<label>Email</label>
    	<input type="email" class="form-control" formControlName="email"  required>
    </div>

    <div class="form-group">
    	<label>Password</label>
   	 <input type="password" class="form-control"  formControlName="password" required>
    </div>

    <div class="form-group">
    	<label>Language</label>
   	 <select class="form-control" formControlName="language"> 
		<option value="">Please select a language</option>
    		<option *ngFor="let lang of langs" [value]="lang">{{lang}}</option>
    	</select>
    </div>

    <pre>{{myform.value | json}}</pre>
  </form>









import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { AppComponent } from './app.component';
 
@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
   
    ReactiveFormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }






import { Component } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent  {
  // Create array to populate language dropdown
  langs: string[] = [
      'English',
      'French',
      'German',
    ]
    // Create Formgroup instance
    myform: FormGroup;

    constructor() {
    // here name is group of first name and last name, formgroup may be nested in another form group.
    this.myform = new FormGroup({
    name: new FormGroup({
    firstName: new FormControl(),
    lastName: new FormControl(),
    }),
    email: new FormControl(),
    password: new FormControl(),
    language: new FormControl()
    });
    }
}



reactive form validation:
---------------------------
   To upgrade our form into an Angular form that can perform validation, 
   we have to create FormControl and FormGroup objects. 

   A FormControl object 
   represents a form control in a form. With it, we can track the value and 
	validation status of an individual form control. 

  A FormGroup object tracks the value and validity state of a group of FormControl objects.

Example

Step 1: Create new angular cli project.

Step2: Create new controller.

ng g c validationexample –flat



<p>
  validationexample example
</p>

<form [formGroup]="form" (ngSubmit)="login()">
  <div class= "form-group">
   	<label for="username">User Name</label>
  	<input type="text" formControlName="username" class="form-control" />
    	<div *ngIf="form.controls.username.touched && !form.controls.username.valid" class="alert alert-danger">
		Username is required
	</div>
  </div> 

  <div class= "form-group">
  	<label for="password">Password</label>
  	<input type="text" formControlName="password" class="form-control" />
  	<div *ngIf="form.controls.password.touched && !form.controls.password.valid" class="alert alert-danger">Password 		is required</div>
    </div>

    <input class="btn btn-primary" [disabled]="form.invalid" type="submit" value="Submit" />

</form>



import { Component, OnInit } from '@angular/core';
 
import { FormGroup , FormControl ,Validators, NgForm} from '@angular/forms';
 
@Component({
  selector: 'app-validationexample',
  templateUrl: './validationexample.component.html',
  styleUrls: ['./validationexample.component.css']
})
export class ValidationexampleComponent  {
// create formgroup object and add formcontrol to perform validations
  form = new FormGroup({
         username: new FormControl('', Validators.required),
         password: new FormControl('', Validators.required)
  });
  login()
  {
    console.log(this.form.value);
  }
}







----------------------------------------
- angular testing jasmine and karma
----------------------------------------


Anugular testing:
---------------
Introduction
What is karma and jasmin?
How Karma & Jasmine  are configured with Angular?
What is the role of Karma.conf.js?
What is the role of test.ts?




step 1: create hello world angular using cli

step 2: hello world contain app.component.spec.ts
 spec file code is created whenever we are created new component, pipe, services etc

 run: ng test
	run karma jasmin test cases

 http://localhost:9876/?id=16030314

 how to configure test env?
 ------------------------
	=> when we create angular app, package.json contain dev-depenencies
	in these dev dependencies we also have dependencies of karma and jasmine

     package.json
     ----------

    "@types/jasmine": "~3.3.8",
    "@types/jasminewd2": "~2.0.3",
    "codelyzer": "^5.0.0",
    "jasmine-core": "~3.4.0",
    "jasmine-spec-reporter": "~4.2.1",
    "karma": "~4.1.0",
    "karma-chrome-launcher": "~2.2.0",
    "karma-coverage-istanbul-reporter": "~2.0.1",
    "karma-jasmine": "~2.0.1",
    "karma-jasmine-html-reporter": "^1.4.0",


    angular.json
    -----------

    "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "main": "src/test.ts",
            "polyfills": "src/polyfills.ts",
            "tsConfig": "tsconfig.spec.json",
            "karmaConfig": "karma.conf.js",
            "assets": [
              "src/favicon.ico",
              "src/assets"
            ],

	=> main act as entry for karma config (karma.config.js), default configuration for karma framework


Hello world test:
----------------


cal.ts
------
export function cal(num1: number, num2: number){
    return num1+num2;
}

cal.spec.ts
----------
import { cal } from "./cal"

describe('cal test',()=>{
    //it define test suite
    it('testing add function', ()=>{
       expect( cal(2,2)).toBe(4);
    })
})

run the test case....


testing string and arrarys:
-------------------------
1.Test Strings using matchers:
    toBe, toEqual, toContain, toMatch
2. Difference between toBe & toEqual
3. Test Arrays using matchers:
     toEqual, toContain


Ex:
describe('string matcher test', ()=>{

   it('testing string,"toBe" for matcher ===', ()=>{
    let firstStr='india';
    expect(firstStr).toBe('india');
   });


   it('testing string,"toEqual" for matcher ==', ()=>{
    let firstStr='india';
    expect(firstStr).toEqual('india');
   })

   it('testing string,"toContain" check hello present in the string', ()=>{
    let firstStr='india is my country';
    expect(firstStr).toContain('my');
   })

   it('testing string,"toMatch" matcher for regular expression', ()=>{
    let firstStr='This 4th lane of Underworld';
    expect(firstStr).toMatch(/\d+/);
    expect(firstStr).toMatch("Underworld");

   })

});


how to exclude an test case?
-------------------

Write x before describe

xdescribe{
}

=> it will remove all test cases from execution




 //testing negative

   it('testing string,"not.toEqual" for matcher ==', ()=>{
    let firstStr='india';
    expect(firstStr).not.toEqual('india 2');
   })


 it('testing string,"toBe" for matcher ===', ()=>{
    let firstStr='india';
    expect(firstStr).not.toBe('india 2');
   });


Difference between toBe & toEqual:
-----------------------------
	toEquals must be used to compare object and array, do deep comparision
 Ex:
    it('toBe vs equals', ()=>{

        let a={val: 10};
        let b={val: 10};

       // expect(a).toBe(b);
       expect(a).toEqual(b);
       });




 Example array:
------------------

 it('array test', ()=>{
        let a=[1,2,3];
        let b=[1,2,3];
       expect(a).toEqual(b);
       });
    

       it('toContain in array of string ', ()=>{
        let a=["i","love","js"];
        
       expect(a).toContain('love');
       });



Understanding setup and tear-down, beforeEach and afterEach
-----------------------------

custreg.ts
--------
export class CustomerReg{
    hotelCap= 30;
    custCount=10;

    regCustomer(){
        return ++this.custCount;
    }
    unRegCustomer(){
        return --this.custCount;
    }
}



custreg.spec.ts
----------

import { CustomerReg } from "./custreg"

describe('cust reg',()=>{

    it('reg customer count should increse by one',()=>{
        let custService=new CustomerReg();
        let custCount=custService.regCustomer();
        expect(custCount).toEqual(11);
    })

    it('un reg customer count should dec by one',()=>{
        let custService=new CustomerReg();
        let custCount=custService.unRegCustomer();
        expect(custCount).toEqual(9);
    })
})

What if we create common custService object?
---------------------------------------

import { CustomerReg } from "./custreg"

describe('cust reg',()=>{
    let custService=new CustomerReg();
    it('reg customer count should increse by one',()=>{
        
        let custCount=custService.regCustomer();
        expect(custCount).toEqual(11);
    })

    it('un reg customer count should dec by one',()=>{
        let custCount=custService.unRegCustomer();
        expect(custCount).toEqual(9);
    })
})

one test pass one fail
-------------------------
 beforeEach and afterEach
------------------------

import { CustomerReg } from "./custreg"

describe('cust reg',()=>{

    let custService:CustomerReg;

    beforeEach(()=>{
        let custService=new CustomerReg();
    });
    afterEach(()=>{
        custService=null;
    });
    beforeAll(()=>{
        console.log(`run before any test cases...`);
    });

    afterAll(()=>{
        console.log(`run before after all test cases runs...`);
    });

    it('reg customer count should increse by one',()=>{
        
        let custCount=custService.regCustomer();
        expect(custCount).toEqual(11);
    })

    it('un reg customer count should dec by one',()=>{
        let custCount=custService.unRegCustomer();
        expect(custCount).toEqual(9);
    })
})





deployment angular to tomcat:
-----------------------------

http://www.thejavageek.com/2018/01/04/deploying-angular-app-tomcat/
https://stackoverflow.com/questions/40852931/how-can-i-deploy-an-angular-2-application-on-tomcat-server-windows-server-2012


ng build --base-href=empappclient


ng build --prod --base-href=empappclient

<script type="text/javascript">
    var cfgApiBaseUrl = "http://localhost:8082/bookapp";
    /*
    IDE: http://localhost:8082"
    Tomcat1: http://localhost:8083/empapp
    */
    window.cfgApiBaseUrl = cfgApiBaseUrl;
  </script>




private BASE_URL = window["cfgApiBaseUrl"] + "/api";

  public ALL_NOTEBOOKS_URL = `${this.BASE_URL}/notebooks/all`;










Check verion of an lib

npm install -g version-check
version-check rxjs




